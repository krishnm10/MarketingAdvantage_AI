import uuid
from datetime import datetime
from sqlalchemy import Column, Text, JSON, Float, TIMESTAMP, ForeignKey, String
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship

from app.db.base import Base


class ClassificationLogsV2(Base):
    """
    ClassificationLogsV2
    ---------------------
    Tracks every classification or reclassification event generated by
    AI agents or human annotators, preserving traceability and auditability.

    NOTE: preserved original column names/types. JSON default uses callable.
    """

    __tablename__ = "classification_logs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    content_id = Column(
        UUID(as_uuid=True),
        ForeignKey("ingested_content.id", ondelete="CASCADE"),
        nullable=False,
    )
    business_id = Column(UUID(as_uuid=True), nullable=True)

    taxonomy_path = Column(Text, nullable=True, doc="Resolved taxonomy hierarchy path")
    confidence = Column(Float, nullable=True, doc="Primary classification confidence")
    model_version = Column(String(128), nullable=True, doc="LLM or embedding model version")
    llm_reason = Column(Text, nullable=True, doc="LLM reasoning or decision explanation")

    embed_scores = Column(JSON, nullable=True, doc="Embedding model metrics & cosine similarities")
    llm_scores = Column(JSON, nullable=True, doc="LLM category probability distributions")

    classification_status = Column(
        String(32),
        default="auto",
        doc="Classification source: auto | human | verified | retrained",
    )

    meta_data = Column(JSON, default=dict, doc="Additional model or runtime metadata")

    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    updated_at = Column(TIMESTAMP, default=datetime.utcnow, onupdate=datetime.utcnow)

    content = relationship("IngestedContentV2", backref="classification_logs", lazy="joined")

    def __repr__(self):
        return (
            f\"<ClassificationLogsV2(id={self.id}, taxonomy_path='{self.taxonomy_path}', "
            f"confidence={self.confidence}, model={self.model_version}, status={self.classification_status})>\"
        )

    def to_dict(self):
        return {
            "id": str(self.id),
            "content_id": str(self.content_id),
            "business_id": str(self.business_id) if self.business_id else None,
            "taxonomy_path": self.taxonomy_path,
            "confidence": self.confidence,
            "model_version": self.model_version,
            "llm_reason": self.llm_reason,
            "embed_scores": self.embed_scores,
            "llm_scores": self.llm_scores,
            "classification_status": self.classification_status,
            "meta_data": self.meta_data,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
